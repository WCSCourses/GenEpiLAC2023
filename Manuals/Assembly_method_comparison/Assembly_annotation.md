<img src="https://coursesandconferences.wellcomeconnectingscience.org/wp-content/themes/wcc_courses_and_conferences/dist/assets/svg/logo.svg" width="200" height="200">



# Genome Assembly and Analysis - Paraguay 2023 <!-- omit in toc -->

### Module Leads: Matt Holden and Mat Beale<!-- omit in toc -->
<br>

# Table of contents <!-- omit in toc -->
- [Module Overview and Aims](#module-overview-and-aims)
- [Introduction](#introduction)
  - [Short-read sequencing assembly](#short-read-sequencing-assembly)
  - [Long-read sequencing assembly](#long-read-sequencing-assembly)
  - [Hybrid Assembly](#hybrid-Assembly)
  - [What assemblies are best?](#what-assemblies-are-best?)
- [Assembly and annotation exercise](#assembly-and-annotation-exercise)
  - [Background](#background)
  - [An outbreak sample](#an-outbreak-sample)
  - [Tasks](#tasks)
  - [The research questions](#the-research-questions)
  - [Examining the resistome of 16B](#examining-the-resistome-of-16B)
    - [Step 1: Download the `ResFinder` database](#Download-the-resfinder-database)
    - [Step 2: Run `ariba` on 16B](#run-ariba-on-16B)
    - [Step 3: Run `ariba` on MW2](#run-ariba-on-MW2)
    - [Step 3: Run `ariba` on MSSA476](#run-ariba-on-MSSA476)
    - [Step 5: Compile the `ariba` results](#compile-the-ariba-results)
    - [Step 6. Visualize in Phandango](#visualize-in-phandango)
  - [Generating a _de novo_ assembly](#generating-a-de-novo-assembly)
  - [Ordering the assembly against a reference chromosome](ordering-the-assembly-against-a-reference-chromosome)
  - [Mapping reads back to the ordered assembly](#Mapping-reads-back-to-the-ordered-assembly)
  - [Annotation transfer](#Annotation-transfer)
  - [Examining the evolution of drug resistance in ST1 _S. aureus_](#Examining-the-evolution-of-drug-resistance-in-ST1-S-aureus)

<br> 

# Module Overview and Aims

<br>

One of the greatest challenges of sequencing a genome is determining how to arrange sequencing reads into chromosomes and plasmids. This process of determining how the reads fit together by looking for overlaps between them is called genome assembly. In this module we are going to look as assemblies using short- and long-reads and see how they can be used to characterize isolates of interest, and when annotated, help answer biological and clinical questions.

Aims of this exercise

*	Use a resistome prediction tool to identify the genetic determinants for antibiotic resistance from sequencing reads
*	To show how short-read data can be assembled into a draft genome
*	Order the draft genome against a reference sequence, and transfer annotation from the reference to the draft genome
*	To show how, using comparative genomics, regions of difference that distinguish genomes can identified and analysed
*	Compare assembled genomes generated from short-read sequence data only, long-read sequence data and combined sort- and long-read sequence data

<br>

# [Introduction](#introduction)

<br>

## [Short-read sequencing assembly](#short-read-sequencing-assembly)

<br>

The data from the Illumina machine comes as relatively short stretches (35-250 bp) of DNA – around 6 billion of them for a typical bacterial genome. These individual sequences are called sequencing reads. There are a range of assembly programs that have been specifically designed to assemble genomes from next generation sequence (NGS) data. Genome assembly using sequence reads of around 100bp is complicated due to the high frequency of repeats longer than the sequence read length in genomes, for example: insertion sequence (IS) elements, rRNA operons; and the massive amount of data the programs have to handle. In addition to finding overlaps in the sequence, the assembly programs can also use information from the predicted insert size where paired reads are used, to link and position reads in an assembly.

Where a genome is piecing together without any reference sequence to compare it to, or scaffold it against, it is termed a _de novo_ assembly. Due to the previously mentioned challenges of assembly, de novo assembly using short reads will not produce complete genomes, but will be fragmented into multiple contiguous sequences (contigs), the order of which is arbitrary, and does not necessarily bear not any relation to their real order in the genome. 


## [Long-read sequencing assembly](#long-read-sequencing-assembly)

<br>

With the availability of real-time sequencing technologies, such as Oxford Nanopore and Pacific Bioscience, it is possible to generate sequence reads that far exceed the size of those produced by Illumina platforms. The size of read can be tens of thousands of base pairs in length, contrasting with the tens or hundreds of base pairs generated by Illumina, which had led to these technologies being term long-read technologies.

Having longer reads, that extend through some of the repeat regions that limit the assembly of short-read sequence data, can help piece together a genome sequence. However due to the higher error rate of some real-time sequencing technologies and the variable distribution of size of reads they generate, mean that generating high quality complete assemblies from long-reads alone can challenging.

## [Hybrid Assembly](#hybrid-Assembly)

<br>

A popular approach to generate complete genomes has been to utilize the accuracy of short-read sequencing data and combine it with the long-range information of long-read sequencing data, in a hybrid assembly approach. This requires sequence data for an isolate to be sequenced using the two different sequencing technologies and then assembled using assembler program that is designed to handle the difference types of data and compare them to find overlaps to stitch the sequences together, accurately predict the sequence in the assembly.

## [What assemblies are best?](#what-assemblies-are-best?)

<br>
Hybrid assemblies that are more complete have advantages for downstream analysis, however require access to sequencing capacity for two different technologies, and incur the extra expense of sequencing the same isolate twice, consequently it is not always practical to use this approach to characterize isolates of interest. Equally, it is not always necessary to generate more complete assemblies if the information you need from the genome is not dependant on knowing the full genomic context, i.e. genotyping and isolate for an biomarker such as an antibiotic gene. To answer the question of what is the best assembly to aim for, it very much depends on what you want to use it for. 

<br>

# [Assembly and annotation exercise](#assembly-and-annotation-exercise)

<br>

## [Background](#background)

<br> 

_Staphylococcus aureus_ is a bacterial pathogen that has gained notoriety in recent years due to its ability to evolve new virulent and drug resistant variants. In particular, the spread of _S. aureus_ in hospitals has placed an increased burden on health care systems; _S. aureus_ is the most common cause of hospital-acquired infection. Accompanying the spread of this bacterium has been an increase in the resistance to antibiotics. In parts of Europe, the US and Japan, 40-60% of all hospital _S. aureus_ are now resistant to the β-lactam antibiotic methicillin. Methicillin-resistant _S. aureus_ (MRSA) strains were first described in the 1960s and successful clones of MRSAs have spread round the globe.

## [An outbreak sample](#an-outbreak-sample)

<br>

In this module we will assemble the genome of a strain of _S. aureus_, 16B, that was sequenced as part of an MRSA outbreak investigation, (Köser _et al_., 2012, N Engl J Med. 366:2267-75). Using multi locus sequence typing (MLST) the isolate was identified as belonging to sequence type 1 (ST1), a lineage of _S. aureus_ that is more frequently associated with infections in the community rather than in hospitals, and tends to be less resistant to antibiotics than the _S. aureus_ commonly associated with hospital-acquired infection.

## [Tasks](#tasks)

<br>

We are going to query the resistome of 16B using `ariba` and a resistance gene database. We will generate an assembly and compare it to the chromosomes of 2 other ST1 isolates: MSSA476, which was isolated in the UK (Holden _et al_., 2004, PNAS. 101:9786-91), and MW2, which was isolated in the USA (Baba _et al_., 2002, Lancet 359:1819-27). Both MSSA476 and MW2 have been completely sequenced, annotated and deposited in EMBL.

<br>

![MSSA476 circular](Circular_1.png)

<br>


## [The research questions](#the-research-questions)

<br>

The three ST1 isolates are closely related but exhibit different antibiotic resistance profiles: 16B is resistant to penicillin, fusidic acid, methicillin and erythromycin; MSSA476 is resistant to penicillin and fusidic acid; and MW2 is resistant to penicillin and methicillin. 

Using a comparative genomic approach we will identify regions of difference, and identify the genetic basis of the antibiotic resistance in 16B, and genetic mechanisms that drive the evolution of resistance.

<br>


## Finding the data 
Navigate to the `Module_6_Genome_Assembly_Analysis` directory

```
cd Module_6_Genome_Assembly_Analysis
```

We can confirm where we are 
```
pwd
```

We can also examine the contents of this file
```
ls -l
```
![directory_contents](Terminal_1.png)

<br>

The folder contains:

- three pairs of sequencing reads :
  - `16B_1.fastq.gz`, `16B_2.fastq.gz`
  - `MSSA476_1.fastq.gz`, `MSSA476_2.fastq.gz`
  - `MW2_1.fastq.gz`, `MW2_2.fastq.gz`
- fasta format files for the chromosomes of MW2 and MSSA476 (`MW2.dna` and `MSSA476.dna`)
- EMBL format files of the annotation of the chromosomes of MW2 and MSSA476 (`MW2.embl` and `MSSA476.embl`) 
- EMBL format files of mobile genetic elements of the chromosomes of MW2 and MSSA476 (`MW2_MGEs.tab` and `MSSA476_MGEs.tab`) 
- a folder containing the EMBL format files of the MSSA476 chromosome and plasmid 
- a folder containing the EMBL pdf files of the Köser _et al_., Holden _et al_., and Baba _et al_. manuscripts


<br>


## [Examining the resistome of 16B](#examining-the-resistome-of-16B)

<br>

One of the benefits of whole genome sequencing bacterial pathogens is that you capture the genomic inventory of the organism. This has been capitalized on in clinical microbiology for the _in silico_ prediction of antibiotic resistance directly from whole genome sequencing data. This is being developed as a alternative to phenotypic sensitivity testing of microorganisms in the laboratory, where microorganisms are routinely sequenced.

For many microorganisms the genetic basis of antibiotic resistance has been extensively studied. This means that the genes responsible for resistance have been identified and sequenced, and can be used to compile a database of resistance determinants and used to query an organism’s genome and define its resistome. Based on the presence or absence of genes or mutations it is possible to make a prediction of the antibiotic sensitives of an organism. For some species of bacteria this works better than others. For example, _S. aureus_ the correlation between the genotype and phenotype for most commonly used antibiotics is above 99%. However, for other organisms, such as members of the _Enterobacteriaceae_, the concordance is a lot lower, as these organisms have a more extensive array of resistance mechanisms and determinants.

A recent review from a EUCAST subcommittee summarized the current development status of WGS for bacterial antimicrobial susceptibility testing (AST) for a range or organisms:

Ellington MJ, _et al_., (2017) The role of whole genome sequencing in antimicrobial susceptibility testing of bacteria: report from the EUCAST Subcommittee. Clin Microbiol Infect. 23:2-22. PubMed PMID: 27890457.

From the phenotypic data you have been given you know that 16B exhibits resistance to penicillin, fusidic acid, methicillin and erythromycin, however you do not know what genes are responsible for this is in this isolate. In the first part of this exercise you are going to use a piece of software, `ariba`, and a publicly available curated antibiotic resistance gene database from ResFinder, to rapidly predict the resistome of 16B from the Illumina sequence reads. You will also do this for this other ST1 _S. aureus_ isolates MW2 and MSSA476, and correlate the phenotypic metadata with the genetic information.

<br>

`ariba` (Antimicrobial Resistance Identifier by Assembly) is a freely available tool (https://github.com/sanger-pathogens/ariba). This tool required a `FASTA` input of reference sequences, which can be a multifasta file or database of antibiotic resistance genes or non-coding sequences. This database will serve as one of your inputs and the other is paired sequence reads. `ariba` reports which of the reference sequences were found, plus detailed information on the quality of the assemblies and any variants between the sequencing reads and the reference sequences. 

`ResFinder`, is a web resource for the prediction of antibiotic resistances (www.genomicepidemiology.org). It used a curated database of over 2100 acquired antibiotic resistance determinants (Zankari E _et al_., (2012) Identification of acquired antimicrobial resistance genes. J Antimicrob Chemother. 67:2640-4).

We have installed `ariba` on the virtual machine, and you will use this to download the `ResFinder` database locally to the virtual machine, and then use it with `ariba` to examine the resistome of your isolates. Further information about `ariba` can be found here: https://github.com/sanger-pathogens/ariba/wiki (Hunt M, _et al_., (2017) `ariba`: rapid antimicrobial resistance genotyping directly from sequencing reads. Microb Genom. 3:e000131) 

The results can then be viewed in `Phandango` (http://jameshadfield.github.io/phandango/), an interactive web tool to visualize your outputs.

<br>

The first part of this exercise will follow 6 steps:

Step 1. Download the ResFinder database using `ariba` and format it
Step 2. Run `ariba` on the 16B fastq reads
Step 3. Run `ariba` on the MW2 fastq reads
Step 4. Run `ariba` on the MSSA476 fastq reads
Step 5. Compile the results from 16B, MW2 and MSSA476
Step 6. Visualize output in Phandango

<br>

## [Step 1: Download the `ResFinder` database](#Download-the-resfinder-database) 

To download the database you use the `ariba` `getref` command. 

In the command below we:

- Specify the database to download
    - `resfinder`
- Specify the output name prefix
    - `out.resfinder`


```
ariba getref resfinder out.resfinder
```


Alternative database options that can be used are: argannot, card, megares, plasmidfinder, resfinder, srst2_argannot, vfdb_core, vfdb_full, virulencefinder.

<br>


Next you need to format the reference database using the `ariba` `prepareref` command. 

In the command below we:

- Specify the file of resistance genes in fasta format
    - `–f out.resfinder.fa`
- Specify the metadata file for the resistance genes
    - `–m out.resfinder.tsv`
- Specify directory that will contained the prepared database files for running `ariba`
    - `out.resfinder.prepareref`


```
ariba prepareref -f out.resfinder.fa -m out.resfinder.tsv out.resfinder.prepareref 
```

<br>

## [Step 2: Run `ariba` on 16B](#run-ariba-on-16B)

Next using the 16B fastq files run local assemblies and call variants using the `ariba` `run` command. 

- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `16B_1.fastq 16B_2.fastq`
- Specify the the directory containing the results
    - `16B_out.run`


```
ariba run out.resfinder.prepareref 16B_1.fastq 16B_2.fastq 16B_out.run
```

<br>

## [Step 3: Run `ariba` on MW2](#run-ariba-on-MW2)

Repeat the `ariba` run on the MW2 fastq files. 


- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `MW2_1.fastq MW2_2.fastq`
- Specify the the directory containing the results
    - `MW2_out.run`


```
ariba run out.resfinder.prepareref MW2_1.fastq MW2_2.fastq MW2_out.run
```

<br>

## [Step 3: Run `ariba` on MSSA476](#run-ariba-on-MSSA476)

Repeat the `ariba` run on the MSSA476 fastq files.

- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `MSSA476_1.fastq MSSA476_2.fastq`
- Specify the the directory containing the results
    - `MSSA476_out.run`


```
ariba run out.resfinder.prepareref MSSA476_1.fastq MSSA476_2.fastq MSSA476_out.run
```

<br>

## [Step 5: Compile the `ariba` results](#compile-the-ariba-results)

Next you need to compile the `ariba` results from the three isolates using the the `ariba` `summary` command.

- Specify the prefix for the output files
    - `out.summary`
- Specify the report files made by the separate runs of `ariba` for each isolate 
    - `16B_out.run/report.tsv MW2_out.run/report.tsv MSSA476_out.run/report.tsv`


```
ariba summary out.summary 16B_out.run/report.tsv MW2_out.run/report.tsv MSSA476_out.run/report.tsv
```

<br>

## [Step 6. Visualize in Phandango](#visualize-in-phandango)

The `ariba` summary command generates three files:

- `out.summary.csv` - summary of identifying genes and matches in the isolates 
- `out.summary.phandango.csv` - a version of summary file for viewing in Phandango
- `out.summary.phandango.tre` - tree based on matches in the out.summary.csv file


To visualize the results open up the Firefox web browser, and type in the URL: https://jameshadfield.github.io/phandango/

From a file view window drag and drop the two `phandango` files, `out.summary.phandango.tre` and `out.summary.phandango.csv`, into the browser window.

![Phandango image](Phandango_1.png)

In the browser window the tree is displayed on the left and represents relationships of the isolates based on the shared resistance determinants displayed in the right-hand panel, where the column indicate genes, and the green blocks indicate matches. The pink blocks indicate that the isolates are negative for those genes.


<br>

## Questions

- What are the genes identified, and which antibiotics do they encode resistance for?

To help you understand what what genes ResFinder is using for different antibiotics you can explore here: https://cge.food.dtu.dk/services/ResFinder/gene_overview.php

- How do the resistomes predicted for each isolate compare with the phenotypic data?


<br>

## [Generating a _de novo_ assembly](#generating-a-de-novo-assembly)

Having identified antibiotic resistance genes using `ariba`, you are now going to continue the exercise exploring the genome of 16B to identify the genomic context of the genes and see if you can find any missing genes. The first step is to generate a _de novo_ assembly of 16B using the `fastq` files. Make sure you are still in the Module 6 directory.  

To generate the _de novo_ assembly you are going to use a assembly package called `velvet` (Zurbino et al., 2008, Genome Res. 8:821-9); other assembly programs are available, e.g. spades (https://github.com/ablab/spades), which we will use in a later exercise. `velvet` was one of the earlier assembly programs and takes in short read sequences, removes errors then produces high quality unique contigs. It then uses paired-end read and long read information, when available, to retrieve the repeated areas between contigs. 

The algorithm at the heart of Velvet is based on de Bruijn graphs (a mathematical structure used to model relationships between objects). When doing assembly with short reads the first step is to find all the possible overlaps between all the reads. One efficient way is to look for k-mers (words/nucleotide patterns of a specific length) in each read. If two reads contain the same k-mer they might also overlap. Each read contains several k-mers, and k-mers from the same read can be connected in a graph. Velvet represents overlaps between k-mers in a de Bruijn graph. By simplifying the graph Velvet can try to generate connected sequences, where k-mers in the graph are connected and thereby it is able to piece together sequences and generate contigs. 

In this module we are not going to explore the options available in Velvet, but are going to run it with basic parameters. If you would like to know more about theory behind Velvet, or the various options, see the Velvet web site (https://github.com/dzerbino/velvet).


<br> 

To perform the assembly you are going to run a series of commands that you will type on the command line. Make sure that you type the commands carefully as UNIX is case sensitive and there were lots text in some of the command lines.

The input files for the velvet de novo assembly are the `16B_1.fastq` and `16B_2.fastq` files that you previously used in with `aria`.

The forward and reverse reads for the isolate 16B were generated using an Illumina HiSeq machine and are 75bp paired-end reads. 

The `velvet` package contains two programs: `velveth` and `velvetg`, which are run in succession to generate the assembly. `velveth` helps you construct the dataset for the following program, `velvetg`, and indicates to the system what each sequence file represents. `velvetg` is the core of `velvet` where the de Bruijn graph is built then manipulated, and which ultimately produces the assembly that we are interested in.

<br>


The first program of the velvet package we are going to use is `velveth`.


- Specify the directory into which results are written
    - `S_aureus_16B.49`
- Specify the is the the k-mer value we are using (i.e. 49 nucleotides)
    - `49`
- Specify the the input files are short paired reads 
    - `-shortPaired`
- Specify the forward and reverse fastq files
    - `-fastq -separate 16B_1.fastq 16B_2.fastq`

Other k-mers can be used and can alter the performance of assembly, however for this module we will run it with a value of 49 which will perform adequately.


```
velveth S_aureus_16B.49 49 -shortPaired -fastq -separate 16B_1.fastq 16B_2.fastq
```


![velveth 1](velveth_1.png)



<br>


The next program of the velvet package we are going to use is `velvetg`.


- Specify the directory in which `velvetg` can find the `velveth` output files which are necessary to run `velvetg`: Sequences and Roadmaps files
    - `S_aureus_16B.49`
- Specify the program to infer the expected coverage of unique regions
    - `-exp_cov auto`
- Specify the minimum contig length of 200 bp exported to the output file
    - `-min_contig_lgth 200`
- Specify the program to infer removal of low coverage nodes
    - `-cov_cutoff auto`
- Specify the expected distance between two paired-end reads in the short-read dataset: 350 bp
    - `-ins_length 350`


```
velvetg S_aureus_16B.49 -exp_cov auto -min_contig_lgth 200 -cov_cutoff auto -ins_length 350
```

![velvetg 1](velvetg_1.png)


<br>


There is a lot of output printed to the screen, but the most important is in the last line:
Final graph has 251 nodes and n50 of 225962, max 557946, total 2777486, using 3846837/4000000 reads. (Result might differ depending on the velvet version used).

This line first gives you a quick idea of the result. 251 nodes (contigs) are in the final graph. An n50 of 225962 means that 50% of the assembly is in contigs of at least 225963 bases. This n50 parameter is most commonly used as an indicator of assembly quality. The higher, the better! max is the length of the longest contig. total is the size of the assembly, here it is 2.78 Mb. The last two numbers tell us how many reads were used from the 4 million pairs.

A typical S. aureus genome is 2.8 Mb in size, therefore the _de novo_ assembly that we have produced should contain over 99% of this isolate’s genome.

All of the results are written into the directory you specified, e.g. `S_aureus_16B.49` 

Use the UNIX `cd` command to move into this directory, and the `ls` command to look at the contents.


![velvetg 2](velvetg_2.png)


The final contigs are in `contigs.fa`. This files contains the contigs in multifasta format, i.e. the sequence of each contig is written as a separate fasta sequence, with all the contigs fasta sequences concatenated together. The `stats.txt` file holds some information about each contig, its length, the coverage, etc.. The other files contain information for the assembler.


<br>

We are now going to look at the assembly in `artemis`.

Type `art &` on the command line of your terminal window and press return. Once you see the initial Artemis window, open the `contigs.fa` file 
via *File*, *Open*.

Once open, zoom out so you can see the whole sequence in your window. The individual contigs in the multifasta file are alternately coloured orange and brown and displayed on he forward DNA line in the sequence view window. To look at a summary of the contigs.fa, click View, then Overview. You should see that there are 35 contigs in total (35 Number of features in active entry).


![Artemis 1](Artemis_1.png)


From the *Graph* menu, open *GC Deviation (G-C)/(G+C)* by clicking on the button next to it.

Rescale the plot for to a more appropriate window size for this zoomed out view: Right click on the graph, and click *Maximum Window Size*, and select *20000*. Then move the graph slider of the right hand side of the screen down to the bottom of the bar.


![Artemis 2](Artemis_2.png)


From the graph you can see that plot generally varies about an upper level and a lower level across the assembly, with shifts occurring at contig boundaries. As you will see there is a GC skew across the chromosome that is caused by a mutation basis that means that the leading strand of the replication fork is G and T rich, as opposed to the lagging strand, which is C and A rich. If you look at the circular diagram of MSSA476 earlier in the module, you can see the GC skew for the MSSA476 chromosome (the purple and olive inner plot on the figure). The origin and the terminus of replications are approximately half way round the chromosome (the origin is at the top, and the terminus is at the bottom), therefore there is a strong signal of GC deviation between these sites, i.e. as you move round the chromosome the GC Deviation plot will be either be at a high or low level, and after the origin or terminus of replication, the plot will shift to converse level. 

Looking at the GC Deviation plot in `artemis` of the 16B assembly you can see there are multiple shifts from high to low indicating that the contigs in the assembly as displayed, are not in the correct order and orientation relative to the true origin and terminus of replication of the 16B chromosome.


<br>


## [Ordering the assembly against a reference chromosome](#ordering-the-assembly-against-a-reference-chromosome)

At the Wellcome Sanger Institute a tool called `abacas` (Assefa _et al_., 2009) was developed to order contigs against a reference sequence. Any spaces between the contigs (gaps) can be filled in with “N” characters to ‘pad’ the sequence with equivalent sized regions to those on the reference that may be missing in the assembly. The result is called a pseudo-molecule. This can be loaded into `act` along with the reference sequence and then be analyzed.

The sequence we are going to use as a reference belongs to an ST1 MSSA strain, MSSA476 (EMBL accession number BX571857). Before we begin, make sure you are back in the Module 6 directory.

<br>


To check where you are use the UNIX `pwd` command. If you were in in the `S_aureus.49` directory, use the `cd ..` command to move into the directory above.

We are going to reorder the 16B assembly against the MSSA476 reference using `abacas`


- Specify the abacas script 
    - `abacas.1.3.1.pl`
- Specify the reference sequence in a single fasta file
    - `-r MSSA476.dna`
- Specify the contigs in multi-fasta format (contig.fa in S_aureus_16B.49 directory)
    - `–q S_aureus_16B.49/contigs.fa`
- Specify the MUMmer program to use: nucmer (nucleotide-nucleotide comparison)
    - ``
- Specify the default nucmer parameters, which is in this case is faster
    - `-d`
- Specify the program to generate a bin of contigs that don’t map. This is very important
    - `-b`
- Specify the program to append contigs in bin to the pseudo-molecule
    - `-a`
- Specify the prefix for the output file name
    - `–o 16B.ordered`

To see a complete list the option available you can type the command: `abacas.1.3.1.pl -h`



```
abacas.1.3.1.pl -r MSSA476.dna -q S_aureus_16B.49/contigs.fa -p nucmer -b -d -a -c -o 16B.ordered
```

<br>


Once `abacas` is done, we are going to use `act` to look at the new ordered contigs.


![abacas 1](abacas_1.png)


Before opening the files in `act`, we are need to generate a `blastn` comparison file, rather than using the comparison file that `abacas` generates. This is because the `abacas` generated file is based on MUMMER and just aligns the contigs and does not report smaller matches within contigs.

Previously we have used pre-generated comparison files for `act`. This time you are going to do it yourself using the locally installed version of `blast`. 

<br>


We will run two programs: `formatdb`, which formats one of the sequences as a `blast` database; and the other `blastall`, runs the `blast` comparison.


First we will run `formatdb`.


- Specify the sequence protein (True or False). Ours is DNA sequence therefore we use F
    - `-p F`
- Specify the input sequence to format
    - `i MSSA476.dna`



```
formatdb -p F -i MSSA476.dna
```


Next we will run `blastall`



- Specify the `blast` program to use
    - `-p blastn`
- Specify the alignment output type (8, one line per entry)
    - `-m 8`
- Specify the database file. This must be the file used for the `formatdb` command
    - `-d MSSA476.dna`
- Specify the query file
    - `-i 16B.ordered.fasta`
- Specify the output file name
    - `-o MSSA476.dna_vs_16B.ordered.fasta`


```
blastall -p blastn -m 8 -d MSSA476.dna -i 16B.ordered.fasta -o MSSA476.dna_vs_16B.ordered.fasta
```

<br>


We are now going to look at the `abacus` ordered 16B assembly in `act` with the `blastn` comparison file we have just generated.


At the prompt type and return the command line:


```
act MSSA476.embl MSSA476.dna_vs_16B.ordered.fasta 16B.ordered.fasta &
```


Once the `act` window loads up, open `16B.ordered.tab` file into the `16B.ordered.fasta` entry by going to the *File* menu, and selecting the *16B.ordered.fasta* option, and right clicking onto the *Read An Entry* option. 

Once ACT has opened, zoom out so you can see the whole of the sequences (you may have to re-size the ACT window) and reduce the size of the BLASTN footprint that is displayed, by moving the slider on the right-hand side of the comparison window down to the bottom of the bar.

As before, display the GC Deviation (G-C)/(G+C) plots for both of the sequences (under the Graph menu there will be two sequences, top and bottom sequences, click on each to open the graphs for each). Remember to rescale the plot for a more appropriate window size (use 20000 as before, then move the graph slider of the right hand side of the screen down to the bottom of the bar).


![ACT zoomed out](ACT_zoomed_out.png)


In the `act` figure there are several regions of interest that are worth investing. The first region we are going to look at is the inverted region in the centre of the assembly that is covered by the hourglass shaped blue matches in the comparison panel. This 130 kb region spans the terminus of replication region, and is present at one end of a contig. At the other end of the putative inverted region there is a contig break. 

![ACT focus region](ACT_focus_region.png)

<br>

## [Mapping reads back to the ordered assembly](#Mapping-reads-back-to-the-ordered-assembly)

In this next exercise you are going to use the same mapping method as you did in Mapping Module, to map the 16B strain forward and reverse reads against the pseudo-molecule that you created using `abacas`. We are then going to look at the aligned mapped reads in `act` by loading the mapped bam file with the `16B.ordered.fasta`.  


First we will run `snippy`.

- Specify the output directory
    - `--outdir 16B_mapping`
- Specify the forward read
    - `--R1 16B_1.fastq`
- Specify the reverse read
    - `--R2 16B_2.fastq`
- Specify the reference sequence to map to
    - `--ref 16B.ordered.fasta`
- Specify the number of cpus
    - `--cpus 4`
- Specify the amount of ram
    - `--ram 4`
- Specify overwriting existing file 
    - `--force`
- Specify no screen output 
    - `--quiet`


```
snippy --outdir 16B_mapping --R1 16B_1.fastq --R2 16B_2.fastq --ref 16B.ordered.fasta --cpus 4 --ram 4 --force --quiet
```


<br>

The bam file contains all the mapping positions on the genome for each individual read is in the `16B_mapping` directory.

Before we can use it in `act` we have to index is using the `samtools` `index` command.


- Specify the bam file to index
    - `16B_mapping/snps.bam`


```
samtools index 16B_mapping/snps.bam
```

<br>


To load the `bam` file into `act`, click *File* on the menu and them click the *16B.ordered.fasta* entry, and then the *Read BAM / VCF*.

In the pop-up box click *Select*, select the `snps.bam` file from the `16B_mapping` directory, click *Open*, then click *OK*.


![ACT bam load](ACT_bam_load.png)



<br>

If you are not already there, go to the inversion region, and the inversion point in the contig (the region below illustrated in the image). You should see the BAM view as a panel at the bottom of the screen.


![CT bam inv 1](CT_bam_inv_1.png)


Zoom in further keeping the inversion site in the centre of the ACT screen.  


![CT bam inv 2](CT_bam_inv_2.png)


The reads in the BAM view appear to break at the junction of the inversion indicated by the `blasts` match; no reads span the junction point (click on the reads around the junction to see their pair) suggesting that there may be problems with the assembly of the 16B DNA across this region. 

To get another perspective of the mapping to this region, change the BAM view to show the inferred size of the insert. To do this right click on the BAM view window, move the cursor over *Views*, and click *Inferred Size*.


![CT bam inv 3](CT_bam_inv_3.png)


From the inferred size view you can see that there are no reads with predicted inserts that span this region. This suggests that the inversion may not be present, and that the sequence generated by Velvet in this region has not assembled correctly, and needs further investigation. To check if this is a mis-assembly, you could change the parameters of the original Velvet runs, or alternatively design PCR primers and do a PCR to check for the orientation of this region in the genomic DNA.

<br>

In addition to allowing us to check for potential mis-assemblies we can also use the mapping data to look for copy number variants in the assembly.

In `act` change the read view back to *Stack view*, and zoom out to see the whole sequence


![CT bam inv 4](CT_bam_inv_4.png)


From this view in `act` you can see that the average coverage across the whole 16B sequence is about 120 fold, and that there is subtle reduction in coverage from the origin to the terminus of replication. You can also see that the non-mapping sequences from the bin at the right-hand side of the sequence have a higher level of coverage than the rest of the sequence that matches to the MSSA476 chromosome.

Zoom into this region to look in more detail.


![CT bam inv 5](CT_bam_inv_5.png)


The non-mapping contigs are indicated by the yellow features. There are 7 contigs and the two larger sequences are 20.6 kb and 2.5 kb. The read coverage across these regions increases considerably from the average (120 fold), to about 400 fold for the 20.6 kb contig, and 1400 fold for the 2.5 kb contig. It is therefore likely that these two contigs are separate multicopy plasmids that are part of the 16B genome.

<br>


## [Annotation transfer](#Annotation-transfer)

Now we have the contigs ordered against the reference, and have mapped back the reads to identify a possible mis-assembly, and also identified putative plasmid sequences. However we are still not yet in a position to drill down into the biology of the strain. For this we need to add some annotation to the newly assembled genome. To do this we can transfer the annotation of reference strain we used in ABACAS, as this has been annotated and is clearly highly related. We have developed a tool called `ratt` (Otto et al., 2011, Nucleic Acids Res 39:e57) that can do this. 

In the first step the similarity between the two sequences is determined and a synteny map is constructed. This map is used to map the annotation of the reference onto the new sequence. In a second step, it tries to correct gene models. One advantage of `ratt` is that the complete annotation is transferred, including descriptions. Thus careful manual annotation from the reference becomes available in the newly sequenced genome. Obviously, where no synteny exists, no transfer can be done. Let’s see if this will work for our assembly.

<br>

As input for `ratt` we use the reference genome’s annotation (the MSSA476 genome consists of a single chromosome and plasmid therefore are going to use them both) and the output of `abacas` (16B.ordered.fasta). 

We will run `ratt`

- Specify the `ratt` script 
    - `start.ratt.sh`
- Specify the directory which contains all the EMBL files to be transferred (EMBL files for the MSSA476 chromosome and plasmid, pSAS)
    - `embl`
- Specify the multifasta file to which the annotation will be mapped
    - `16B.ordered.fasta`
- Specify the prefix to give results files
    - `16B`
- Specify the Transfer type: Assembly, transfer between different assemblies 
    - `Assembly`
- Specify the output summary file
    - `> out.ratt.txt`



```
start.ratt.sh embl 16B.ordered.fasta 16B Assembly > out.ratt.txt
```

<br>


`ratt` generates a lot of output, such as synteny block information, which genes were corrected, and most importantly how many genes were transferred. A summary of this is in the file `out.ratt.txt`.

To take a look at the contents of this file type at prompt and return the command line:

```
more out.ratt.txt
```


![ratt output](ratt_output.png)


`ratt` produces an EMBL format file containing the assembly and transferred annotation ending in the suffix .final.embl (e.g. 16B.ordered_staph-55e08.q2c2068.final.embl)

Load this up into ACT with the MSS476 reference chromosome. At the prompt type and return the command line:

```
act MSSA476.embl MSSA476.dna_vs_16B.ordered.fasta 16B.ordered_staph-55e08.q2c2068.final.embl &
```


Once the `act` window loads up, open `16B.ordered.tab` file into the *16B.ordered.fasta* entry by going to the *File* menu, and selecting the *16B.ordered.fasta* option, and right clicking onto the *Read An Entry* option. 

<br>

RATT has transferred 2432 gene features to the reference, and if you look in `act` you will see that most of the 16B assembly now has annotation. There are a few regions that do not have annotation, and these mainly coincide with regions that do not share DNA-DNA identity with the reference. We will quickly have a look at these regions.


![ACT 3 regions](ACT_3_regions.png)


<br>

### Region 1


![Region 1](Region_1.png)


In this region near at the left hand side of the reference chromosome and near the origin of replication you can see that there are two regions without annotation transferred. The first is at the very end of the assembly. If you look at this region, it matches to DNA in the reference chromosome. This contig spans the origin of replication and therefore matches two separate regions of the reference (left and right ends of the MSSA476 chromosome), therefore `ratt` has failed transfer annotation to the whole of this contig because it has effectively been split and separated in comparison to the reference.

The second region lacking annotation spans two contigs. This ~22 kb region, contains `blastn` hits in the middle of the sequence, that match sequence in the MSSA476 reference (top) that is also present in the 16B assembly (positions 85000 to 90000). This suggest that the ~22 kb region shares some similarity with the region downstream.

<br>

### Region 2


![Region 2](Region_2.png)


From the `act` figure it would appear that there is a large insert in the 16B assembly relative to the MSSA476. If you zoom in and look at the sequence you will see that is composed of Ns rather than bases (in the figure you can make out regions with Ns, as they do not have any black lines that indicate stop codons on the forward and reverse translations). In this case ABACAS has mis-predicted a gap in this region, and therefore `ratt` has not transferred annotation.

<br>

### Region 3


![Region 3](Region_3.png)


In this region near at the right hand side of the assembly, we have the non-mapping contigs (yellow). Previously we have seen that the two largest contigs are likely to be separate plasmids. The larger of the contigs has annotation transferred to it, however if you look in `act`, you will see that there it has no `blastn` matches to the MSSA476 chromosome. If you then look at the annotation that has been transferred, you will see that it has come from the MSSA476 plasmid, pSAS, rather than the chromosome, this is because we included EMBL files for both the plasmid and chromosome in the `ratt` transfer. This indicates that 16B contains a similar plasmid to that found in MSSA46.

<br>


For the regions of difference that do not have any annotation, we can use a useful function of `act` (and also `artemis`) to see what similar regions there are in the public sequence databases. To do this we are going to the run a BLAST search at the NCBI from the *Run* menu in `act`.

Navigate yourself back to Region 1. Select the DNA region in the 16B assembly that is unique (*Right click* and hold, drag the cursor to the end of the region and release). *Left click* the *Create* menu, and move the cursor over the lower entry, and click *Feature From Base Range*. In the pop up feature box, change the *Key* to *misc_feature*, then click *Apply*. 


![ACT blast 1](ACT_blast_1.png)


Click on the *misc_feature* you have just created. Click the *Run* menu, and move the cursor the over lower entry, then over *NCBI searches*.


![ACT blast 2](ACT_blast_2.png)


In the NCBI searches sub-menu you will see the various flavours of BLAST that you can run. We are going to run a BLASTN (DNA-DNA comparison) and also a BLASTX (translated DNA-Protein comparison) search for the feature. First click *blastn*. An *Options for blastn* window will appear that allows you to change the blast parameters. We are going to run it with the default settings, therefore click *OK*.

The BLAST job is now sent by ACT to the NCBI, and the Web browser window will open, and the results will appear when they have finished.

<br> 

Look at the BLASTN results and see what matches there are, and how much coverage there is of the region we are interested in.

- What is the identity of some of these sequences?

- Does it correspond to particular type of mobile genetic element (MGE) and what genes would you expect to find on this element?

<br>

Having seen the DNA-DNA matches, we are now going to repeat the NCBI search with BLASTX this time (Click the *Run* menu, and move the cursor over the lower entry, then over *NCBI searches*, and click *blastx*). This will search for protein coding sequences in the region of interest that have BLAST matches to proteins in UniProt.


- What is the identity of the matching sequences and their predicted function?

- How does this relate to antibiotic resistance?

- Can you find matches to the genes ARIBA identified?


<br>


## [Examining the evolution of drug resistance in ST1 _S. aureus_](#Examining-the-evolution-of-drug-resistance-in-ST1-S-aureus)


Up until now we have compared the 16B assembly to only one other ST1 _S. aureus_ strain, MSSA476. We are now going introduce another strain to the comparison, MW2, and start looking at the genetic differences between the isolates that may impact on their biology. Although MW2 was isolated in a different country (USA), many thousands of miles away from 16B and MSSA476 (both UK), it still belongs to the same clone, and probably share a common ancestor tens rather than hundreds of years ago. A clinically important phenotypic difference between these isolates are their antibiotic resistances:

- 16B – penicillin*R*, fusidic acid*R*, methicillin*R*, erythromycin*R*
- MSSA476 – penicillin*R*, fusidic acid*R*
- MW2 – penicillin*R*, methicillin*R*

As you will hopefully have just discovered, it is possible to use genome sequence data to find the genes responsible for antibiotic resistance. Examining the genetic context of these genes helps us to understand the mechanism that are driving the evolution of resistance in these _S. aureus_ isolates. In this next part of the Module you are going use the comparisons with MW2 and MSSA476 to identify regions of difference regions that distinguish the isolates, and explain the differences in the antibiotic resistance phenotypes.

<br>

Before we begin this exercise close down any `act` session you have open.

In order to examine the regions of difference in the 16B assembly with MW2 we are going generate a comparison file that we can load in ACT, as we did previously for MSSA476.

At the prompt type and return the command line:

```
formatdb -p F -i 16B.ordered.fasta
```


Next type and return the command line:

```
blastall -p blastn -m 8 -d 16B.ordered.fasta -i MW2.dna -o 16B.ordered.fasta_vs_MW2.dna
```


We are now going to load up the three sequences and relevant comparison files into `act`. You can do this either from the command line or by clicking on the ACT icon. 


If you prefer to do it from the command line you can type:

```
act MSSA476.embl MSSA476.dna_vs_16B.ordered.fasta 16B.ordered_staph-55e08.q2c2068.final.embl 16B.ordered.fasta_vs_MW2.dna MW2.embl &
```


Now that you have included the MW2 sequence to the comparison you should see an `act` view with three DNA panels and two comparison panels separating them. In this zoomed out view, MSSA476 is on the top, 16B is in the middle and MW2 on the bottom. You will also notice that in the `act` menu at the top there are now three entry options. 


![ACT 3way 1](ACT_3way_1.png)


To help you with your investigations, we have also provided two additional annotation files that contain misc_features which mark the extent of MGEs identified in the MSSA476 and MW2 chromosomes. These can be loaded into the appropriate entry (from the menu click *File*, the entry you want, then *Read An Entry*). The misc_features are colour coded in the ACT view according to the type of MGE (see legend on on the circular diagram of MSSA476).


![ACT 3way 2](ACT_3way_2.png)


Here is the Region 1 that we have looked at previously, now with MW2 at the bottom. The regions of 16B that lacking annotation transferred from MSSA476, contains a matches to a region of the MW2. Does the identity of this MW2 region correspond to what you have seen from the NCBI BLAST searches? What has occurred in this region of the 16B chromosome that could explain the structure of this region in comparison to the other strains?


![ACT 3way 3](ACT_3way_3.png)


Compare the other regions containing MGEs. How do these regions vary in the three strains, and what do they encode? Does this explain the differences in the antibiotics phenotypes of the isolates? Can you find any other important genes associated with MGEs that are vary in the isolates that are clinical relevant (clue, think toxins).

<br>

## Annotation from scratch

In the example we have looked at, we are fortunate that we have annotation for a closely related reference sequence that that we can use to transfer to our isolate of interest’s assembly. In this case most of the query isolate’s assembly is covered by the transferred annotation. What if you are not so lucky, and you do not have an appropriate reference which you can use? What options are available to you?

One option would be to use an annotation program such as `prokka` (Seemann T. (2014) Prokka: rapid prokaryotic genome annotation. Bioinformatics. 30:2068-9. doi: 10.1093/bioinformatics/btu153) or `bakta` (Schwengers O et al., (2021). Bakta: rapid and standardized annotation of bacterial genomes via alignment-free sequence identification. Microbial Genomics, 7(11). https://doi.org/10.1099/mgen.0.000685)

Both of these program are installed on the disk image. If you have time why don't you have a go at running them on the 16B.ordered.fasta sequence.


<br>


To run `prokka`.

- Specify the output directory
    - `--outdir 16B_prokka`
- Specify the prefix
    - `--prefix 16B`
- Specify the multifasta file to be annotated
    - `16B.ordered.fasta`


```
prokka --outdir 16B_prokka --prefix 16B 16B.ordered.fasta
```


To visualize the annotation in Artemis type:


```
art 6B_prokka/16B.gff
```

<br>

To run `bakta` first download the most recent compatible database


- Specify the `bakta` program to run
    - `download`
- Specify the output directory
    - `--output bakta_database`
- Specify the database versions (available as either full or light):
    - `--type light`


```
bakta_db download --output bakta_database --type light
```


Then run `bakta` to annotate your sequence.

- Specify the database directory
    - `--db bakta_database`
- Specify the multifasta file to be annotated
    - `16B.ordered.fasta`


```
bakta --db bakta_database 16B.ordered.fasta
```

Like for `prokka`, `bakta` produces annotations & sequences in GFF3 format, which can be loaded in `artemis` or `act` and explored.

<img src="https://coursesandconferences.wellcomeconnectingscience.org/wp-content/themes/wcc_courses_and_conferences/dist/assets/svg/logo.svg" width="200" height="200">



# Genome Assembly and Analysis - Paraguay 2023 <!-- omit in toc -->

### Module Leads: Matt Holden and Mat Beale<!-- omit in toc -->
<br>

# Table of contents <!-- omit in toc -->
- [Module Overview and Aims](#module-overview-and-aims)
- [Introduction](#introduction)
  - [Short-read sequencing assembly](#short-read-sequencing-assembly)
  - [Long-read sequencing assembly](#long-read-sequencing-assembly)
  - [Hybrid Assembly](#hybrid-Assembly)
  - [What assemblies are best?](#what-assemblies-are-best?)
- [Exercise A](#exercise-A)
  - [Background](#background)
  - [An outbreak sample](#an-outbreak-sample)
  - [Tasks](#tasks)
  - [The research questions](#the-research-questions)
  - [A: Examining the resistome of 16B](#examining-the-resistome-of-16B)
    - [Step 1: Download the `ResFinder` database](#Download-the-resfinder-database)
    - [Step 2: Run `ariba` on 16B](#run-ariba-on-16B)
    - [Step 3: Run `ariba` on MW2](#run-ariba-on-MW2)
    - [Step 3: Run `ariba` on MSSA476](#run-ariba-on-MSSA476)
    - [Step 5: Compile the `ariba` results](#compile-the-ariba-results)
    - [Step 6. Visualize in Phandango](#visualize-in-phandango)

<br> 

# Module Overview and Aims

<br>

One of the greatest challenges of sequencing a genome is determining how to arrange sequencing reads into chromosomes and plasmids. This process of determining how the reads fit together by looking for overlaps between them is called genome assembly. In this module we are going to look as assemblies using short- and long-reads and see how they can be used to characterize isolates of interest, and when annotated, help answer biological and clinical questions.

Aims of this exercise

*	Use a resistome prediction tool to identify the genetic determinants for antibiotic resistance from sequencing reads
*	To show how short-read data can be assembled into a draft genome
*	Order the draft genome against a reference sequence, and transfer annotation from the reference to the draft genome
*	To show how, using comparative genomics, regions of difference that distinguish genomes can identified and analysed
*	Compare assembled genomes generated from short-read sequence data only, long-read sequence data and combined sort- and long-read sequence data

<br>

# [Introduction](#introduction)

<br>

## [Short-read sequencing assembly](#short-read-sequencing-assembly)

<br>

The data from the Illumina machine comes as relatively short stretches (35-250 bp) of DNA – around 6 billion of them for a typical bacterial genome. These individual sequences are called sequencing reads. There are a range of assembly programs that have been specifically designed to assemble genomes from next generation sequence (NGS) data. Genome assembly using sequence reads of around 100bp is complicated due to the high frequency of repeats longer than the sequence read length in genomes, for example: insertion sequence (IS) elements, rRNA operons; and the massive amount of data the programs have to handle. In addition to finding overlaps in the sequence, the assembly programs can also use information from the predicted insert size where paired reads are used, to link and position reads in an assembly.

Where a genome is piecing together without any reference sequence to compare it to, or scaffold it against, it is termed a _de novo_ assembly. Due to the previously mentioned challenges of assembly, de novo assembly using short reads will not produce complete genomes, but will be fragmented into multiple contiguous sequences (contigs), the order of which is arbitrary, and does not necessarily bear not any relation to their real order in the genome. 


## [Long-read sequencing assembly](#long-read-sequencing-assembly)

<br>

With the availability of real-time sequencing technologies, such as Oxford Nanopore and Pacific Bioscience, it is possible to generate sequence reads that far exceed the size of those produced by Illumina platforms. The size of read can be tens of thousands of base pairs in length, contrasting with the tens or hundreds of base pairs generated by Illumina, which had led to these technologies being term long-read technologies.

Having longer reads, that extend through some of the repeat regions that limit the assembly of short-read sequence data, can help piece together a genome sequence. However due to the higher error rate of some real-time sequencing technologies and the variable distribution of size of reads they generate, mean that generating high quality complete assemblies from long-reads alone can challenging.

## [Hybrid Assembly](#hybrid-Assembly)

<br>

A popular approach to generate complete genomes has been to utilize the accuracy of short-read sequencing data and combine it with the long-range information of long-read sequencing data, in a hybrid assembly approach. This requires sequence data for an isolate to be sequenced using the two different sequencing technologies and then assembled using assembler program that is designed to handle the difference types of data and compare them to find overlaps to stitch the sequences together, accurately predict the sequence in the assembly.

## [What assemblies are best?](#what-assemblies-are-best?)

<br>
Hybrid assemblies that are more complete have advantages for downstream analysis, however require access to sequencing capacity for two different technologies, and incur the extra expense of sequencing the same isolate twice, consequently it is not always practical to use this approach to characterize isolates of interest. Equally, it is not always necessary to generate more complete assemblies if the information you need from the genome is not dependant on knowing the full genomic context, i.e. genotyping and isolate for an biomarker such as an antibiotic gene. To answer the question of what is the best assembly to aim for, it very much depends on what you want to use it for. 

<br>

# [Assembly and annotation exercise(#assembly-and-annotation-exercise)

<br>

## [Background](#background)

<br> 

_Staphylococcus aureus_ is a bacterial pathogen that has gained notoriety in recent years due to its ability to evolve new virulent and drug resistant variants. In particular, the spread of _S. aureus_ in hospitals has placed an increased burden on health care systems; _S. aureus_ is the most common cause of hospital-acquired infection. Accompanying the spread of this bacterium has been an increase in the resistance to antibiotics. In parts of Europe, the US and Japan, 40-60% of all hospital _S. aureus_ are now resistant to the β-lactam antibiotic methicillin. Methicillin-resistant _S. aureus_ (MRSA) strains were first described in the 1960s and successful clones of MRSAs have spread round the globe.

## [An outbreak sample](#an-outbreak-sample)

<br>

In this module we will assemble the genome of a strain of _S. aureus_, 16B, that was sequenced as part of an MRSA outbreak investigation, (Köser et al., 2012, N Engl J Med. 366:2267-75). Using multi locus sequence typing (MLST) the isolate was identified as belonging to sequence type 1 (ST1), a lineage of _S. aureus_ that is more frequently associated with infections in the community rather than in hospitals, and tends to be less resistant to antibiotics than the _S. aureus_ commonly associated with hospital-acquired infection.

## [Tasks](#tasks)

<br>

We are going to query the resistome of 16B using `ariba` and a resistance gene database. We will generate an assembly and compare it to the chromosomes of 2 other ST1 isolates: MSSA476, which was isolated in the UK (Holden et al., 2004, PNAS. 101:9786-91), and MW2, which was isolated in the USA (Baba et al., 2002, Lancet 359:1819-27). Both MSSA476 and MW2 have been completely sequenced, annotated and deposited in EMBL.

<br>

![MSSA476 circular](Circular_1.png)

<br>


## [The research questions](#the-research-questions)

<br>

The three ST1 isolates are closely related but exhibit different antibiotic resistance profiles: 16B is resistant to penicillin, fusidic acid, methicillin and erythromycin; MSSA476 is resistant to penicillin and fusidic acid; and MW2 is resistant to penicillin and methicillin. 

Using a comparative genomic approach we will identify regions of difference, and identify the genetic basis of the antibiotic resistance in 16B, and genetic mechanisms that drive the evolution of resistance.

<br>


## Finding the data 
Navigate to the `Module_6_Assembly_Analysis` directory

```
cd Module_6_Assembly_Analysis
```

We can confirm where we are 
```
pwd
```

We can also examine the contents of this file
```
ls -l
```
![directory_contents](Directory_ls_start.png)

<br>

The folder contains:

- three pairs of sequencing reads :
  - `16B_1.fastq.gz`, `16B_2.fastq.gz`
  - `MSSA476_1.fastq.gz`, `MSSA476_2.fastq.gz`
  - `MW2_1.fastq.gz`, `MW2_2.fastq.gz`
- a folder containing the EMBL format file of reference genomes

<br>



## [A: Examining the resistome of 16B](#examining-the-resistome-of-16B)

<br>

One of the benefits of whole genome sequencing bacterial pathogens is that you capture the genomic inventory of the organism. This has been capitalized on in clinical microbiology for the _in silico_ prediction of antibiotic resistance directly from whole genome sequencing data. This is being developed as a alternative to phenotypic sensitivity testing of microorganisms in the laboratory, where microorganisms are routinely sequenced.

For many microorganisms the genetic basis of antibiotic resistance has been extensively studied. This means that the genes responsible for resistance have been identified and sequenced, and can be used to compile a database of resistance determinants and used to query an organism’s genome and define its resistome. Based on the presence or absence of genes or mutations it is possible to make a prediction of the antibiotic sensitives of an organism. For some species of bacteria this works better than others. For example, _S. aureus_ the correlation between the genotype and phenotype for most commonly used antibiotics is above 99%. However, for other organisms, such as members of the _Enterobacteriaceae_, the concordance is a lot lower, as these organisms have a more extensive array of resistance mechanisms and determinants.

A recent review from a EUCAST subcommittee summarized the current development status of WGS for bacterial antimicrobial susceptibility testing (AST) for a range or organisms:

Ellington MJ, et al., (2017) The role of whole genome sequencing in antimicrobial susceptibility testing of bacteria: report from the EUCAST Subcommittee. Clin Microbiol Infect. 23:2-22. PubMed PMID: 27890457.

From the phenotypic data you have been given you know that 16B exhibits resistance to penicillin, fusidic acid, methicillin and erythromycin, however you do not know what genes are responsible for this is in this isolate. In the first part of this exercise you are going to use a piece of software, `ariba`, and a publicly available curated antibiotic resistance gene database from ResFinder, to rapidly predict the resistome of 16B from the Illumina sequence reads. You will also do this for this other ST1 _S. aureus_ isolates MW2 and MSSA476, and correlate the phenotypic metadata with the genetic information.

<br>

`ariba` (Antimicrobial Resistance Identifier by Assembly) is a freely available tool (https://github.com/sanger-pathogens/`ariba`). This tool required a `FASTA` input of reference sequences, which can be a multifasta file or database of antibiotic resistance genes or non-coding sequences. This database will serve as one of your inputs and the other is paired sequence reads. `ariba` reports which of the reference sequences were found, plus detailed information on the quality of the assemblies and any variants between the sequencing reads and the reference sequences. 

`ResFinder`, is a web resource for the prediction of antibiotic resistances (www.genomicepidemiology.org). It used a curated database of over 2100 acquired antibiotic resistance determinants (Zankari E et al., (2012) Identification of acquired antimicrobial resistance genes. J Antimicrob Chemother. 67:2640-4).

We have installed `ariba` on the virtual machine, and you will use this to download the `ResFinder` database locally to the virtual machine, and then use it with `ariba` to examine the resistome of your isolates. Further information about `ariba` can be found here: https://github.com/sanger-pathogens/`ariba`/wiki (Hunt M, et al., (2017) `ariba`: rapid antimicrobial resistance genotyping directly from sequencing reads. Microb Genom. 3:e000131) 

The results can then be viewed in `Phandango` (http://jameshadfield.github.io/phandango/), an interactive web tool to visualize your outputs.

<br>

The first part of this exercise will follow 6 steps:

Step 1. Download the ResFinder database using `ariba` and format it
Step 2. Run `ariba` on the 16B fastq reads
Step 3. Run `ariba` on the MW2 fastq reads
Step 4. Run `ariba` on the MSSA476 fastq reads
Step 5. Compile the results from 16B, MW2 and MSSA476
Step 6. Visualize output in Phandango

<br>

## [Step 1: Download the `ResFinder` database](#Download-the-resfinder-database) 

To download the database you use the `ariba` `getref` command. 

In the command below we:

- Specify the database to download
    - `resfinder`
- Specify the output name prefix
    - `out.resfinder`

```
ariba getref resfinder out.resfinder
```

Alternative database options that can be used are: argannot, card, megares, plasmidfinder, resfinder, srst2_argannot, vfdb_core, vfdb_full, virulencefinder.

<br>

Next you need to format the reference database using the `ariba` `prepareref` command. 

In the command below we:

- Specify the file of resistance genes in fasta format
    - `–f out.resfinder.fa`
- Specify the metadata file for the resistance genes
    - `–m out.resfinder.tsv`
- Specify directory that will contained the prepared database files for running `ariba`
    - `out.resfinder.prepareref`

```
ariba prepareref –f out.resfinder.fa –m out.resfinder.tsv out.resfinder.prepareref 
```
<br>

## [Step 2: Run `ariba` on 16B](#run-ariba-on-16B)

Next using the 16B fastq files run local assemblies and call variants using the `ariba` `run` command. 

- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `16B_1.fastq 16B_2.fastq`
- Specify the the directory containing the results
    - `16B_out.run`

```
ariba run out.resfinder.prepareref 16B_1.fastq 16B_2.fastq 16B_out.run
```

<br>

## [Step 3: Run `ariba` on MW2](#run-ariba-on-MW2)

Repeat the `ariba` run on the MW2 fastq files. 


- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `MW2_1.fastq MW2_2.fastq`
- Specify the the directory containing the results
    - `MW2_out.run`

```
ariba run out.resfinder.prepareref MW2_1.fastq MW2_2.fastq MW2_out.run
```

<br>

## [Step 3: Run `ariba` on MSSA476](#run-ariba-on-MSSA476)

Repeat the `ariba` run on the MSSA476 fastq files.

- Specify the directory containing the ResFinder database files
    - `out.resfinder.prepareref`
- Specify the 16B forward and reverse fastq files
    - `MSSA476_1.fastq MSSA476_2.fastq`
- Specify the the directory containing the results
    - `MSSA476_out.run`

```
ariba run out.resfinder.prepareref MSSA476_1.fastq MSSA476_2.fastq MSSA476_out.run
```

<br>

## [Step 5: Compile the `ariba` results](#compile-the-ariba-results)

Next you need to compile the `ariba` results from the three isolates using the the `ariba` `summary` command.

- Specify the prefix for the output files
    - `out.summary`
- Specify the the report files made by the separate runs of `ariba` for each isolate 
    - `16B_out.run/report.tsv MW2_out.run/report.tsv MSSA476_out.run/report.tsv`
- Specify the 
    - ``


```
ariba summary out.summary 16B_out.run/report.tsv MW2_out.run/report.tsv MSSA476_out.run/report.tsv
```

<br>

## [Step 6. Visualize in Phandango](#visualize-in-phandango)

The `ariba` summary command generates three files:

- `out.summary.csv` - summary of identifying genes and matches in the isolates 
- `out.summary.phandango.csv` - a version of summary file for viewing in Phandango
- `out.summary.phandango.tre` - tree based on matches in the out.summary.csv file

To visualize the results open up the web browser, and type in the URL: https://jameshadfield.github.io/phandango/


![Phandango image](Phandango_1.png)


<br>
